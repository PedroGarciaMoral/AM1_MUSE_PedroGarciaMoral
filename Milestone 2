#Milestone 2 - AM1- MUSE
#Integracion numérica de Cauchy Problem con funciones 
#Este código integra la órbita de un cuerpo bajo la influencia de un campo gravitatorio central 
#Se utilizan los métodos de Euler, RK4, Crank-Nicolson y Euler inverso (implicito)

import numpy as np
from numpy.linalg import norm
import matplotlib.pyplot as plt
import warnings

# Funciones de integradores unipaso
 # 1) EULER
 # 2) RK4
 # 3) CRANK-NICOLSON
 # 4) INVERSE EULER

def Euler(F, U, t, dt):
    return U + dt * F(U, t)

def RK4(F, U, t, dt):
    k1 = F(U, t)
    k2 = F(U + 0.5 * dt * k1, t + 0.5 * dt)
    k3 = F(U + 0.5 * dt * k2, t + 0.5 * dt)
    k4 = F(U + dt * k3, t + dt)
    return U + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)

def Crank_Nicolson(F, U, t, dt):
    tol = 1e-12
    max_iter = 100
    itU = U + dt * F(U, t)
    for _ in range(max_iter):
        U_new = U + 0.5 * dt * (F(U, t) + F(itU, t + dt))
        if norm(U_new - itU) < tol:
            return U_new
        itU = U_new
    warnings.warn(f"Crank-Nicolson sin convergencia en t={t:.4f}")
    return itU

def Inverse_Euler(F, U, t, dt):
    tol = 1e-12
    max_iter = 100
    itU = U + dt * F(U, t)
    for _ in range(max_iter):
        U_new = U + dt * F(itU, t + dt)
        if norm(U_new - itU) < tol:
            return U_new
        itU = U_new
    warnings.warn(f"Inverse-Euler sin convergencia en t={t:.4f}")
    return itU

# Integrador de Cauchy general
def Cauchy_problem(scheme, U0, F, times):
    U = np.zeros((len(times), len(U0)))
    U[0] = U0
    for k in range(len(times)-1):
        t = times[k]
        dt = times[k+1] - times[k]
        U[k+1] = scheme(F, U[k], t, dt)
    return U

# Problema concreto
def F(U, t):
    # U = [x, y, vx, vy]
    r = U[0:2]
    v = U[2:4]
    rnorm = norm(r)
    accel = -r / (rnorm**3 + 1e-16)
    #añadida tolerancia para evitar singularidad
    return np.concatenate((v, accel))

if __name__ == "__main__":
    # Condiciones iniciales
    r0 = np.array([0.0, 1.0])
    dr0 = np.array([1.0, 0.0])
    U0 = np.concatenate((r0, dr0))
    # Discretización temporal
    T = 5.0
    N = 1000
    dt = T / N
    times = np.linspace(0, T, N+1)

    methods = {
        "Euler": Euler,
        "RK4": RK4,
        "Crank-Nicolson": Crank_Nicolson,
        "Inverse-Euler": Inverse_Euler,
    }

    plt.figure(figsize=(8,8))
    colors = {"Euler":"C0", "RK4":"C1", "Crank-Nicolson":"C2", "Inverse-Euler":"C3"}

    for name, scheme in methods.items():
        U = Cauchy_problem(scheme, U0, F, times)
        plt.plot(U[:,0], U[:,1], label=name, color=colors.get(name,'k'), linewidth=0.6)

    plt.xlabel("x")
    plt.ylabel("y")
    plt.axis("equal")
    plt.xlim(-2, 2)
    plt.ylim(-2, 2)
    plt.title(f"Comparativa integradores (T={T}, N={N})")
    plt.legend()
    plt.show()
